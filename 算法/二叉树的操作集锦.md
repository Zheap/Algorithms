# 二叉树的操作集锦

### 树的结构

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int n, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```

## 二叉树的遍历

### 二叉树的前序遍历

#### 前序遍历 - 递归

```c++
vector<int> res;
vector<int> preOrder(TreeNode* root){
	if (root == nullptr) return {};
    preOrder(root);
    return res;
}

void preOrder(TreeNode* root){
    if (root == nullptr) return;
    res.push_back(root->val);
    preOrder(root->left);
    preOrder(root->right);
}
```

#### 前序遍历 - 栈实现

```c++
vector<int> preOrder(TreeNode* root){
    if (root == nullptr) return {};
    vector<int> res;
    stack<TreeNode*> s;
    s.push(root);
    while(!s.empty()){
        TreeNode* cur = s.top();
        s.pop();
        res.push_back(cur->val);
        if (cur->left){
            s.push(cur->left);
        }
        if (cur->right){
            s.push(cur->right);
        }
    }
    return res; 
}
```

### 二叉树的中序遍历

#### 中序遍历 - 递归

```c++
vector<int> res;
vector<int> inOrder(TreeNode* root){
    if (root == nullptr) return {};
    inOrder(root);
    return res;
}

void inOrder(TreeNode* root){
    if (root == nullptr) return;
    inOrder(root->left);
    res.push_back(root->val);
    inOrder(root->right);
}
```

#### 中序遍历 - 栈实现

```C++
vector<int> inOrder(TreeNode* root){
    if (root == nullptr) return {};
    vector<int> res;
    stack<TreeNode*> s;
    TreeNode* cur = root;
    while(cur || !s.empty()){
        while(cur){
            s.push(cur);
            cur = cur->left;
        }
        cur = s.top();
        s.pop();
        res.push_back(cur->val);
        cur = cur->right;
    }
    return res;
}
```

### 二叉树的后序遍历

#### 后序遍历 - 递归

```c++
vector<int> res;
vector<int> postOrder(TreeNode* root){
    if (root == nullptr) return {};
    postOrder(root);
    return res;
}
void postOrder(TreeNode* root){
    if (root == nullptr) return;
    postOrder(root->left);
    postOrder(root->right);
    res.push_back(root->val);
}
```

#### 后序遍历 - 栈实现

```c++
vector<int> postOrder(TreeNode* root){
    if (root == nullptr) return {};
    vector<int> res;
    stack<TreeNode*> s1;
    stack<TreeNode*> s2;
    s1.push(root);
    while(!s1.empty()){
        TreeNode* cur = s1.top();
        s1.pop();
        s2.push(cur);
        if (cur->left){
            s1.push(cur->left);
        }
        if (cur->right){
            s1.push(cur->right);
        }
    }
    while(!s2.empty()){
        res.push_back(s2.top()->val);
        s2.pop();
    }
    return res;
}
```

